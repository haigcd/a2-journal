#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <stdbool.h>
#include "editor.h"
#include "util.h"

/*
 * Define control codes for special keys for readability.
 */
#define KEY_LEFT_ARROW 0x08  /* ASCII Backspace, generated by ← key */
#define KEY_RIGHT_ARROW 0x15 /* ASCII NAK, generated by → key */
#define KEY_UP_ARROW 0x0B    /* ASCII VT (Ctrl+K), generated by ↑ key on IIe */
#define KEY_DOWN_ARROW 0x0A  /* ASCII LF (Ctrl+J), generated by ↓ key on IIe */
#define KEY_CTRL_S 0x13      /* ASCII Ctrl+S */
#define KEY_RETURN 0x0D      /* ASCII Carriage Return, generated by RETURN key */

#define EDITOR_START_Y 2
#define EDITOR_MAX_X 39
#define EDITOR_MAX_Y 21

/* Calculate the number of characters that fit on one editable page. */
#define EDITOR_PAGE_SIZE ((EDITOR_MAX_Y - EDITOR_START_Y + 1) * (EDITOR_MAX_X + 1))

/* Module-level (static global) variables to hold the editor's state. */
static char *editor_buffer;
static unsigned int editor_buffer_size;
static unsigned int editor_buffer_cursor;
static unsigned int max_buffer_cursor;

/*
 * Calculates the current page number based on the cursor's position in the buffer.
 * Page numbers are 0-indexed.
 */
static int get_current_page_number()
{
    return (editor_buffer_cursor / EDITOR_PAGE_SIZE);
}

static int total_pages()
{
    return (max_buffer_cursor / EDITOR_PAGE_SIZE);
}

/*
 * The header is static and only needs to be drawn when the screen is cleared,
 * as opposed to the footer, which contains dynamic information. This draws
 * the static header, as well as the horizontal rule at the bottom of the page.
 */
static void draw_frame(void)
{
    unsigned int percent;
    unsigned char old_x, old_y;
    char header_str[41];

    /* Save current cursor position */
    old_x = wherex();
    old_y = wherey();

    /* Move to top-left to draw the header */
    gotoxy(0, 0);

    // Draw the header
    sprintf(header_str, "Editing Entry | Ctrl+S Save; Ctrl+K Up");
    printf("%-40s", header_str);
    print_horizontal_rule();

    // draw horizontal rule that belongs above the footer.
    gotoxy(0, EDITOR_MAX_Y + 1);
    print_horizontal_rule();

    /* Restore cursor to its original position */
    gotoxy(old_x, old_y);
    cursor(1);
}

/*
 * Draws the editor footer, including position information.
 */
static void update_footer(void)
{
    unsigned int percent;
    unsigned char old_x, old_y;
    char footer_str[41];

    /* Save current cursor position */
    old_x = wherex();
    old_y = wherey();

    /*
     * Calculate usage percentage. We cast to unsigned long during the
     * multiplication to prevent potential overflow, as current_size * 100
     * could exceed the 65535 limit of a 16-bit unsigned int.
     */
    percent = (unsigned int)(((unsigned long)max_buffer_cursor * 100) / editor_buffer_size);

    gotoxy(0, EDITOR_MAX_Y + 2);
    sprintf(footer_str, "Pg %d/%d | %d%%", get_current_page_number() + 1, total_pages() + 1, percent);
    printf("%-15s", footer_str);

    /* Restore cursor to its original position */
    gotoxy(old_x, old_y);
    cursor(1);
}

/*
 * Pads the buffer to the end of the current line with spaces, as necessary.
 * This is less space-efficient but it enables simple pagination, because we know a screen
 * consists of exactly 20 x 40 characters.
 */
static void pad_to_end_of_line(void)
{
    unsigned char x = wherex();
    unsigned char y = wherey();

    // Loop from current X to the right margin, printing spaces
    // if the buffer is empty, or the existing character, if not
    while (x <= EDITOR_MAX_X && editor_buffer_cursor < editor_buffer_size)
    {
        char c;

        gotoxy(x++, y);

        if (editor_buffer[editor_buffer_cursor] == NULL)
        {
            c = ' ';
            editor_buffer[editor_buffer_cursor] = ' ';
        }
        else
        {
            c = editor_buffer[editor_buffer_cursor];
        }

        cputc(c);

        editor_buffer_cursor++;

        if (editor_buffer_cursor > max_buffer_cursor)
        {
            max_buffer_cursor++;
        }
    }
}

static void render_buffer_page(int page_number)
{
    int i;

    clrscr();
    draw_frame();

    gotoxy(0, EDITOR_START_Y);

    for (i = page_number * EDITOR_PAGE_SIZE; i < (page_number + 1) * EDITOR_PAGE_SIZE; i++)
    {
        if (i >= editor_buffer_size || editor_buffer[i] == NULL)
        {
            break;
        }

        if (editor_buffer[i] == NULL)
        {
            cputc(' ');
        }
        else if (editor_buffer[i] <= 8)
        {
            cputc('.');
        }
        else
        {
            cputc(editor_buffer[i]);
        }
    }
}

void run_editor(char *buffer, unsigned int buffer_size)
{
    char key;

    /* Initialize the module-level state variables */
    editor_buffer = buffer;
    editor_buffer_size = buffer_size;
    editor_buffer_cursor = 0;

    /* Determine the initial length of the content. */
    max_buffer_cursor = strlen(editor_buffer);

    // draw the initial page
    render_buffer_page(0);
    
    gotoxy(0, EDITOR_START_Y);

    /* Main editor loop */
    for (;;)
    {
        /* Draw the header on every loop to keep the size / page number updated */
        update_footer();

        key = cgetc(); /* Wait for a keypress */

        /* TODO: bell if this keypress would go beyond 100% of the buffer */

        if (key == KEY_CTRL_S)
        {
            /* User wants to save and exit the editor */
            break;
        }
        else if (key == KEY_RETURN)
        {
            /* User pressed RETURN, let's fill the rest of the line with spaces */
            if (editor_buffer_cursor < editor_buffer_size - 1)
            {
                pad_to_end_of_line();

                /* Check if we've hit the bottom of the screen */
                if (wherey() > EDITOR_MAX_Y)
                {
                    render_buffer_page(get_current_page_number());
                    gotoxy(0, EDITOR_START_Y);
                }
            }
        }
        else if (key == KEY_LEFT_ARROW)
        {
            /* User pressed the left-arrow key */
            if (editor_buffer_cursor > 0)
            {
                unsigned char old_x = wherex();
                unsigned char old_y = wherey();

                editor_buffer_cursor--;

                if (old_x > 0)
                {
                    /* Simple case: not at the left edge */
                    gotox(old_x - 1);
                }
                else if (old_y > EDITOR_START_Y)
                {
                    /* We were at the left edge, move to end of previous line */
                    gotoxy(EDITOR_MAX_X, old_y - 1);
                }
                else if (old_y == EDITOR_START_Y)
                {
                    // decrementing the editor_buffer_cursor already put us on the
                    // previous page, so we can use get_current_page_number
                    render_buffer_page(get_current_page_number());
                    gotoxy(EDITOR_MAX_X, EDITOR_MAX_Y);
                }
            }
        }
        else if (key >= 32 && key <= 126)
        {
            /* It's a printable ASCII character */
            if (editor_buffer_cursor < editor_buffer_size - 1)
            {
                cputc(key);
                editor_buffer[editor_buffer_cursor] = key;
                editor_buffer_cursor++;

                /* If we've typed past the previous end, update the max cursor */
                if (editor_buffer_cursor > max_buffer_cursor)
                {
                    max_buffer_cursor = editor_buffer_cursor;
                }

                /* Check if we've wrapped to the next line and hit the bottom */
                if (wherey() > EDITOR_MAX_Y)
                {
                    render_buffer_page(get_current_page_number());
                    gotoxy(0, EDITOR_START_Y);
                }
            }
        }
        else if (key == KEY_RIGHT_ARROW)
        {
            // make sure to add a space to the buffer if the
            // current buffer position is NULL
            if (editor_buffer[editor_buffer_cursor] == NULL)
            {
                editor_buffer[editor_buffer_cursor] = ' ';
            }
            editor_buffer_cursor++;

            // update the highest buffer cursor position, if necessary
            if (editor_buffer_cursor > max_buffer_cursor)
            {
                max_buffer_cursor = editor_buffer_cursor;
            }

            if (wherex() < EDITOR_MAX_X)
            {
                // simple case, move right
                gotox(wherex() + 1);
            }
            else if (wherey() < EDITOR_MAX_Y)
            {
                // at the end of the line, and at the end of the page
                gotoxy(0, wherey() + 1);
            }
            else
            {
                render_buffer_page(get_current_page_number());
                gotoxy(0, EDITOR_START_Y);
            }
        }
        else if (key == KEY_UP_ARROW)
        {
            unsigned char old_x = wherex();
            unsigned char old_y = wherey();
            int current_page = get_current_page_number();

            // move EDITOR_MAX_X characters back in the buffer
            // or to index 0 if we are on the first line of the first page
            if (editor_buffer_cursor < EDITOR_MAX_X)
            {
                editor_buffer_cursor = 0;
            }
            else
            {
                editor_buffer_cursor -= EDITOR_MAX_X + 1;
            }

            if (old_y > EDITOR_START_Y)
            {
                // we are below the editor start line; simply move up a line
                gotoxy(old_x, old_y - 1);
            }
            else if (current_page > 0)
            {
                // we are on at least the second page, move back a page
                render_buffer_page(get_current_page_number());
                gotoxy(old_x, EDITOR_MAX_Y);
            }
            else
            {
                // we are in the middle of the top row on the first page
                gotoxy(0, EDITOR_START_Y);
            }
        }
        else if (key == KEY_DOWN_ARROW)
        {
            /* TODO: Handle moving the cursor down */
        }
    }

    /* Turn off the cursor when the editor exits */
    cursor(0);
}